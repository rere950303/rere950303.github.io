<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.20.2 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Spring][Core] 스프링 핵심 원리-기본편 - YHW Blog</title>
<meta name="description" content="새로운 배움을 기록하고 공유합니다">


  <meta name="author" content="yhw">
  
  <meta property="article:author" content="yhw">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="YHW Blog">
<meta property="og:title" content="[Spring][Core] 스프링 핵심 원리-기본편">
<meta property="og:url" content="https://rere950303.github.io/spring/core/SpringCore_basic/">


  <meta property="og:description" content="새로운 배움을 기록하고 공유합니다">







  <meta property="article:published_time" content="2021-09-22T00:00:00+09:00">





  

  


<link rel="canonical" href="https://rere950303.github.io/spring/core/SpringCore_basic/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "yhw",
      "url": "https://rere950303.github.io/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="YHW Blog Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
<link rel="manifest" href="/favicon/site.webmanifest">
<link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo/logo.png" alt=""></a>
        
        <a class="site-title" href="/">
          YHW Blog
          <span class="site-subtitle">새로운 배움을 기록하고 공유합니다</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/categories/">categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">tags</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="https://rere950303.github.io/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#spring" itemprop="item"><span itemprop="name">Spring</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#core" itemprop="item"><span itemprop="name">Core</span></a>
          <meta itemprop="position" content="3" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">[Spring][Core] 스프링 핵심 원리-기본편</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/images/bio/photo.jpg" alt="yhw" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">yhw</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>어제와 다른 오늘, 오늘 같은 내일</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">팔로우</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Republic of Korea</span>
        </li>
      

      
        
          
            <li><a href="mailto:yhwjjang1995@naver.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
        
          
        
          
        
          
            <li><a href="https://github.com/rere950303" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Spring][Core] 스프링 핵심 원리-기본편">
    <meta itemprop="description" content="">
    <meta itemprop="datePublished" content="2021-09-22T00:00:00+09:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Spring][Core] 스프링 핵심 원리-기본편
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2021-09-22T00:00:00+09:00">September 22, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 분 소요
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              
                <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On This Page</h4></header>
                <ul class="toc__menu">
  <li><a href="#들어가며">들어가며</a></li>
  <li><a href="#객체-지향-설계와-스프링">객체 지향 설계와 스프링</a>
    <ul>
      <li><a href="#좋은-객체-지향-프로그래밍">좋은 객체 지향 프로그래밍</a></li>
      <li><a href="#좋은-객체-지향-설계의-5가지-원칙solid">좋은 객체 지향 설계의 5가지 원칙(SOLID)</a></li>
      <li><a href="#객체-지향-설계와-스프링-1">객체 지향 설계와 스프링</a></li>
    </ul>
  </li>
  <li><a href="#ioc제어의-역전-di-그리고-컨테이너">IoC(제어의 역전), DI, 그리고 컨테이너</a>
    <ul>
      <li><a href="#제어의-역전">제어의 역전</a></li>
      <li><a href="#di">DI</a></li>
      <li><a href="#di-컨테이너">DI 컨테이너</a></li>
    </ul>
  </li>
  <li><a href="#스프링-컨테이너와-스프링-빈">스프링 컨테이너와 스프링 빈</a>
    <ul>
      <li><a href="#스프링-컨테이너">스프링 컨테이너</a></li>
      <li><a href="#beanfactory">BeanFactory</a></li>
      <li><a href="#applicationcontext">ApplicationContext</a></li>
      <li><a href="#beandefinition인터페이스">BeanDefinition(인터페이스)</a></li>
    </ul>
  </li>
  <li><a href="#싱글톤-컨테이너">싱글톤 컨테이너</a>
    <ul>
      <li><a href="#싱글톤-패턴">싱글톤 패턴</a></li>
      <li><a href="#싱글톤-컨테이너-1">싱글톤 컨테이너</a></li>
      <li><a href="#싱글톤-방식의-주의점">싱글톤 방식의 주의점</a></li>
      <li><a href="#configuration과-싱글톤">Configuration과 싱글톤</a></li>
    </ul>
  </li>
  <li><a href="#컴포넌트-스캔">컴포넌트 스캔</a>
    <ul>
      <li><a href="#컴포넌트-스캔과-의존관계-자동-주입">컴포넌트 스캔과 의존관계 자동 주입</a></li>
      <li><a href="#탐색-위치와-기본-스캔-대상">탐색 위치와 기본 스캔 대상</a></li>
      <li><a href="#중복-등록과-충돌">중복 등록과 충돌</a></li>
    </ul>
  </li>
  <li><a href="#의존관계-자동-주입">의존관계 자동 주입</a>
    <ul>
      <li><a href="#다양한-의존관계-주입-방법">다양한 의존관계 주입 방법</a></li>
      <li><a href="#옵션-처리">옵션 처리</a></li>
      <li><a href="#조회-빈이-2개-이상">조회 빈이 2개 이상</a></li>
    </ul>
  </li>
  <li><a href="#빈-생명주기-콜백">빈 생명주기 콜백</a>
    <ul>
      <li><a href="#빈-생명주기-콜백-시작">빈 생명주기 콜백 시작</a></li>
      <li><a href="#인터페이스-initializingbean-disposablebean">인터페이스 InitializingBean, DisposableBean</a></li>
      <li><a href="#빈-등록-초기화-소멸-메서드">빈 등록 초기화, 소멸 메서드</a></li>
      <li><a href="#애노테이션-postconstruct-predestroy">애노테이션 @PostConstruct, @PreDestroy</a></li>
    </ul>
  </li>
  <li><a href="#빈-스코프">빈 스코프</a>
    <ul>
      <li><a href="#빈-스코프란">빈 스코프란</a></li>
      <li><a href="#프로토타입-스코프">프로토타입 스코프</a></li>
      <li><a href="#프로토타입-스코프---싱글톤-빈과-함께-사용시-문제">프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제</a></li>
      <li><a href="#프로토타입-스코프---싱글톤-빈과-함께-사용시-provider로-문제-해결">프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결</a>
        <ul>
          <li><a href="#objectfactory-objectprovider">ObjectFactory, ObjectProvider</a></li>
          <li><a href="#jsr-330-provider">JSR-330 Provider</a></li>
        </ul>
      </li>
      <li><a href="#웹-스코프">웹 스코프</a></li>
      <li><a href="#request-스코프와-provider">request 스코프와 Provider</a></li>
      <li><a href="#스코프와-프록시">스코프와 프록시</a></li>
    </ul>
  </li>
</ul>

              
            </nav>
            <nav class="toc-custom">
              
            </nav>
          </aside>
        
        <h2 id="들어가며">들어가며</h2>
<p>해당 게시글은 인프런 김영한 강사님의 <a href="https://www.inflearn.com/course/스프링-핵심-원리-기본편/dashboard">스프링 핵심 원리 - 기본편</a> 강의를 바탕으로 쓰였음을 미리 밝힙니다.</p>
<h2 id="객체-지향-설계와-스프링">객체 지향 설계와 스프링</h2>
<h3 id="좋은-객체-지향-프로그래밍">좋은 객체 지향 프로그래밍</h3>
<ul>
  <li>스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크</li>
  <li>객체 지향 언어의 특징: 캡슐화, <u>다형성</u>, 추상화, 상속</li>
  <li>역할과 구현의 분리 -&gt; 인터페이스와 구현클래스</li>
  <li>다형성으로 인터페이스를 구현한 객체(서버 기능 구현)를 실행 시점에 유연하게 변경</li>
  <li>확장 가능한 설계, 클라이언트에 영향을 주지 않는 구현클래스의 변경</li>
  <li>스프링에서 이야기하는 제어의 역전, 의존관계 주입은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원</li>
</ul>

<h3 id="좋은-객체-지향-설계의-5가지-원칙solid">좋은 객체 지향 설계의 5가지 원칙(SOLID)</h3>
<ul>
  <li>SRP: 단일 책임 원칙(변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것)</li>
  <li>OCP: 개방-폐쇄 원칙(확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 이를 위해서는 서비스 로직에서  클라이언트 본인이 구현클래스에 의존하면 안된다)</li>
  <li>LSP: 리스코프 치환 원칙(다형성에서 구현클래스는 인터페이스 규약과 기능을 다 지켜야 한다는 것)</li>
  <li>ISP: 인터페이스 분리 원칙(수 많은 기능을 포함하는 범용 인터페이스보다 특정 클라이언트를 위한 인터페이스 지향)</li>
  <li>DIP: 의존관계 역전 원칙(추상화에 의존해야 하며 구체화에 의존하면 안된다. 즉 구현클래스가 아닌 인터페이스에만 의존해야 한다.)</li>
</ul>

<p>다형성 만으로는 서비스 로직에서 인터페이스 <u>뿐만 아니라</u> 구현클래스에도 의존하므로 구현클래스가 달라지는 경우 코드변경이 일어나 OCP, DIP를 지킬 수 없다.</p>
<h3 id="객체-지향-설계와-스프링-1">객체 지향 설계와 스프링</h3>
<ul>
  <li>스프링은 DI 기술(DI 컨테이너)로 다형성 + OCP, DIP를 가능하게 지원</li>
  <li>즉 클라이언트 코드의 변경 없이 기능 확장 지원</li>
</ul>

<h2 id="ioc제어의-역전-di-그리고-컨테이너">IoC(제어의 역전), DI, 그리고 컨테이너</h2>
<h3 id="제어의-역전">제어의 역전</h3>
<ul>
  <li>사용 영역과 구성 영역의 분리(관심사의 분리)</li>
  <li>사용 영역인 서비스 로직은 어떠한 구현객체가 들어오는지 모른체 자신의 기능과 로직만을 실행할 뿐이다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">프레임워크</th>
      <th style="text-align: center">라이브러리</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크다</td>
      <td style="text-align: center">내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리다</td>
    </tr>
  </tbody>
</table>

<h3 id="di">DI</h3>
<ul>
  <li>서비스 로직(클라이언트)은 인터페이스만 의존한다</li>
  <li>정적인 의존관계(인터페이스)와 동적인 의존관계(인터페이스의 구현객체)</li>
</ul>

<h3 id="di-컨테이너">DI 컨테이너</h3>
<ul>
  <li>인터페이스 구현객체를 생성하고 관리하여 의존관계를 연결</li>
</ul>

<h2 id="스프링-컨테이너와-스프링-빈">스프링 컨테이너와 스프링 빈</h2>
<h3 id="스프링-컨테이너">스프링 컨테이너</h3>
<ul>
  <li>ApplicationContext(인터페이스)를 스프링 컨테이너라고 한다.</li>
  <li>XML기반 또는 애노테이션 기반의 자바 설정 클래스로 만들 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">@Configuration</code>이 붙은 클래스를 컨테이너 설정 정보로 활용한다. <code class="language-plaintext highlighter-rouge">@Bean</code> 이 붙은 메서드를 모두 호출해서 반환된 객체를 컨테이너에 빈으로 등록한다.</li>
  <li>빈 이름의 디폴트 값은 메서드 이름이며 항상 다른 이름은 부여해야 한다.</li>
</ul>

<h3 id="beanfactory">BeanFactory</h3>
<ul>
  <li>스프링 컨테이너의 최상위 인터페이스</li>
  <li>빈을 관리하고 조회하는 역할</li>
</ul>

<h3 id="applicationcontext">ApplicationContext</h3>
<ul>
  <li>BeanFactory 기능을 상속받아 부가 기능을 지원</li>
  <li>메시지소스를 활용한 국제화 기능</li>
  <li>환경변수(로컬, 개발, 운영)</li>
  <li>편리한 리소스 조회</li>
</ul>

<h3 id="beandefinition인터페이스">BeanDefinition(인터페이스)</h3>
<ul>
  <li>스프링이 다양한 형태의 설정 정보(XML, 애노테이션)를 BeanDefinition으로 추상화</li>
  <li>빈 설정 메타정보로서 <code class="language-plaintext highlighter-rouge">@Bean</code>당 각각 하나씩 메타정보가 생성된다.</li>
  <li>ApplicationContext는 BeanDefinitionReader를 이용하여 BeanDefinition를 생성하고 이를 이용해 빈으로 등록한다.</li>
</ul>

<h2 id="싱글톤-컨테이너">싱글톤 컨테이너</h2>
<h3 id="싱글톤-패턴">싱글톤 패턴</h3>
<ul>
  <li>스프링 없는 순수한 컨테이너는 요청을 할 때 마다 객체를 새로 생성하여 메모리 낭비가 심하다.</li>
  <li>해당 객체를 딱 1개만 생성하고 공유하도록 설계</li>
  <li><code class="language-plaintext highlighter-rouge">static</code>으로 객체를 하나만 생성한 후 생성자를 <code class="language-plaintext highlighter-rouge">private</code>으로 설정하여 새로운 인스턴스 생성을 막음과 동시에 싱글톤을 보장한다.</li>
</ul>

<p>—&gt; 문제점: 코드가 많이 들어가고 클라이언트가 서비스 구현 클래스에 의존하여 DIP, OCP위반 가능성이 있다. 또한 내부 속성을 변경하기 어렵고 <code class="language-plaintext highlighter-rouge">private</code>생성자로 자식 클래스를 만들기 어려워 유연성이 떨어진다.</p>
<h3 id="싱글톤-컨테이너-1">싱글톤 컨테이너</h3>
<ul>
  <li>싱글톤 패턴을 이용하지 않고도 빈을 싱글톤으로 관리</li>
  <li>싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지</li>
</ul>

<h3 id="싱글톤-방식의-주의점">싱글톤 방식의 주의점</h3>
<ul>
  <li>하나의 객체 인스턴스를 <strong>공유</strong>하기 때문에 무상태로 설계해야 한다.</li>
  <li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안되고 읽기만 가능해야 한다.</li>
</ul>

<h3 id="configuration과-싱글톤"><code class="language-plaintext highlighter-rouge">Configuration</code>과 싱글톤</h3>
<ul>
  <li>스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 <code class="language-plaintext highlighter-rouge">AppConfig</code>클래스를 상속받은 임의의 다른 클래스를 만들고, 그 다른 클래스를 빈으로 등록한다.</li>
  <li>컨테이너에 이미 빈으로 등록이 되었다면 존재하는 빈을 반환하고, 그게 아니면 빈을 생성해서 컨테이너에 등록한 후에 해당 빈을 반환한다.</li>
</ul>

<h2 id="컴포넌트-스캔">컴포넌트 스캔</h2>
<h3 id="컴포넌트-스캔과-의존관계-자동-주입">컴포넌트 스캔과 의존관계 자동 주입</h3>
<ul>
  <li>스프링은 설정 정보가 없어도 자동으로 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공</li>
  <li>의존관계도 자동 주입하는 <code class="language-plaintext highlighter-rouge">Autowired</code>라는 기능을 제공</li>
  <li><code class="language-plaintext highlighter-rouge">Component</code>애노테이션이 붙은 클래스를 스캔해서 빈으로 등록한다.</li>
</ul>

<h3 id="탐색-위치와-기본-스캔-대상">탐색 위치와 기본 스캔 대상</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">basePackages</code>로 탐색할 패키지의 시작 위치를 정한다.</li>
  <li>지정하지 않으면 <code class="language-plaintext highlighter-rouge">ComponentScan</code>이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">@Controller</code>, <code class="language-plaintext highlighter-rouge">@Service</code>, <code class="language-plaintext highlighter-rouge">@Repository</code>, <code class="language-plaintext highlighter-rouge">@Configuration</code>도 스캔 대상이다.</li>
</ul>

<h3 id="중복-등록과-충돌">중복 등록과 충돌</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">자동 빈 등록 vs 자동 빈 등록</th>
      <th style="text-align: center">수동 빈 등록 vs 자동 빈 등록</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ConflictingBeanDefinitionException</code><br />예외 발생</td>
      <td style="text-align: center">수동 빈 등록이 우선권을 가진다. 수동 빈이 자동 빈을 오버라이딩 한다. 단 버그 발생 우려로 최근 스프링 부트는 오류가 발생하도록 기본 값을 바꾸었다.</td>
    </tr>
  </tbody>
</table>

<h2 id="의존관계-자동-주입">의존관계 자동 주입</h2>
<h3 id="다양한-의존관계-주입-방법">다양한 의존관계 주입 방법</h3>
<ol>
  <li>생성자 주입
    <ul>
      <li>생성자 호출시점에 딱 1번만 호출되는 것이 보장</li>
      <li>불변, 필수 의존관계에 사용</li>
      <li>생성자가 1개만 있으면 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 생략해도 된다.</li>
    </ul>
  </li>
  <li>수정자 주입
    <ul>
      <li>setter 메서드를 통해 의존관계를 주입</li>
      <li>선택, 변경 가능성이 있는 의존관계에 사용</li>
    </ul>
  </li>
  <li>필드 주입
    <ul>
      <li>외부에서 변경이 불가능해서 테스트 하기 힘들다.</li>
      <li>컨테이너 없이 테스트 하는 경우 결국 setter가 필요하므로 사용하지 말자.</li>
    </ul>
  </li>
</ol>

<p>—&gt; 생성자 주입을 선택</p>
<ol>
  <li>대부분 의존관계는 불변이다. 생성자 주입은 객체가 생성될때 한 번만 호출되므로 불변으로 설계가 가능하다.</li>
  <li>순수한 자바 코드로만 테스트 진행시 수정자 주입은 실행은 되지만 NPE가 발생한다. 생성자 주입은 컴파일 오류가 발생한다.</li>
  <li><code class="language-plaintext highlighter-rouge">final</code>키워드로 컴파일 오류(생성자 오류)를 발생시킨다. 오직 생성자 주입만 키워드를 사용할 수 있다.</li>
</ol>

<h3 id="옵션-처리">옵션 처리</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@Autowired(required=false)</code>: 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨</li>
  <li><code class="language-plaintext highlighter-rouge">@Nullable</code>: 자동 주입할 대상이 없으면 null이 입력된다.</li>
  <li><code class="language-plaintext highlighter-rouge">Optional&lt;&gt;</code>: 자동 주입할 대상이 없으면 Optional.empty가 입력된다.</li>
</ul>

<h3 id="조회-빈이-2개-이상">조회 빈이 2개 이상</h3>
<p><code class="language-plaintext highlighter-rouge">@Autowired</code>는 타입으로 조회하므로 <code class="language-plaintext highlighter-rouge">NoUniqueBeanDefinitionException</code>오류가 발생한다.<br /><br />
—&gt; 해결방법</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">@Autowired</code>필드 명 매칭
    <ul>
      <li>타입 매칭을 시도하고 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름 매칭</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@Quilifier</code>사용
    <ul>
      <li>추가 구분자를 붙여주는 방법이지 빈 이름을 변경하는 것은 아니다.</li>
      <li>추가 구분자로 못찾으면 구분자의 이름과 같은 이름을 가진 빈을 추가로 찾는다.</li>
      <li><code class="language-plaintext highlighter-rouge">Primary</code>보다 우선권이 높다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Primary</code>사용
    <ul>
      <li>우선순위를 정하는 방법이다.</li>
    </ul>
  </li>
  <li>애노테이션 직접 만들기
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@Quilifier</code>는 문자로써 컴파일시 타입 체크가 안된다.</li>
    </ul>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">,</span> <span class="nc">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">,</span> <span class="nc">ElementType</span><span class="o">.</span><span class="na">PARAMETER</span><span class="o">,</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">,</span> <span class="nc">ElementType</span><span class="o">.</span><span class="na">ANNOTATION_TYPE</span><span class="o">})</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"mainDiscountPolicy"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">MainDiscountPolicy</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>
<h2 id="빈-생명주기-콜백">빈 생명주기 콜백</h2>
<h3 id="빈-생명주기-콜백-시작">빈 생명주기 콜백 시작</h3>
<ul>
  <li>스프링 빈은 객체 생성 -&gt; 의존관계 주입이라는 라이프 사이클을 가진다. 하지만 생성자 주입의 경우는 동시에 일어난다.</li>
  <li>초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다.</li>
  <li>스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려준다. 또한 컨테이너가 종료되기 직전 소멸 콜백을 준다.</li>
  <li>스프링 빈의 이벤트 라이프사이클<br />
컨테이너 생성 -&gt; 빈 생성 -&gt; 의존관계 주입 -&gt; 초기화 콜백 -&gt; 사용 -&gt; 소멸전 콜백 -&gt; 스프링 종료</li>
  <li>객체의 생성과 초기화의 분리: 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 요지보수에 좋다.</li>
</ul>

<h3 id="인터페이스-initializingbean-disposablebean">인터페이스 InitializingBean, DisposableBean</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">InitializingBean</code> 은 <code class="language-plaintext highlighter-rouge">afterPropertiesSet()</code> 메서드로 초기화를 지원한다.</li>
  <li><code class="language-plaintext highlighter-rouge">DisposableBean</code> 은 <code class="language-plaintext highlighter-rouge">destroy()</code> 메서드로 소멸을 지원한다.</li>
  <li>단, 코드가 스프링 전용 인터페이스에 의존하며 코드를 수정할 수 없는 외부 라이브러리에 적용할 수 없다.</li>
</ul>

<h3 id="빈-등록-초기화-소멸-메서드">빈 등록 초기화, 소멸 메서드</h3>
<ul>
  <li>설정 정보에 <code class="language-plaintext highlighter-rouge">@Bean(initMethod = "init", destroyMethod = "close")</code> 처럼 초기화, 소멸 메서드를 지정할 수 있다.</li>
  <li>코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 적용할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">@Bean</code>의 destroyMethod는 기본값이 <code class="language-plaintext highlighter-rouge">(inferred)</code> 으로 등록되어 있다. 이 추론 기능은 <code class="language-plaintext highlighter-rouge">close</code> , <code class="language-plaintext highlighter-rouge">shutdown</code> 라는 이름의 메서드를 자동으로 호출해준다. 이름 그대로 종료 메서드를 추론해서 호출해준다. 따라서 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다. 추론 기능을 사용하기 싫으면<code class="language-plaintext highlighter-rouge">destroyMethod=""</code> 처럼 빈 공백을 지정하면 된다.</li>
</ul>

<h3 id="애노테이션-postconstruct-predestroy">애노테이션 <code class="language-plaintext highlighter-rouge">@PostConstruct</code>, <code class="language-plaintext highlighter-rouge">@PreDestroy</code></h3>
<ul>
  <li>가장 편리하며 자바 표준 기술이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.</li>
  <li>외부 라이브러리에는 적용하지 못하므로 이 경우 <code class="language-plaintext highlighter-rouge">@Bean</code> 기능을 사용하자.</li>
</ul>

<h2 id="빈-스코프">빈 스코프</h2>
<h3 id="빈-스코프란">빈 스코프란</h3>
<p>스코프는 번역 그대로 빈이 존재 할 수 있는 범위를 뜻한다.</p>
<ol>
  <li>싱글톤: 기본 스코프, 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.</li>
  <li>프로토타입: 컨테이너는 프로토타입 빈의 생성과 의존관계 주입과 초기화 까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다. 따라서 종료메서드가 호출되지 않는다.</li>
  <li>웹 관련 스코프
    <ul>
      <li>request: 웹 요청이 들어오고 나갈떄 까지 유지되는 스코프이다.</li>
      <li>session: 웹 세션이 생성되고 종료될 떄 까지 유지되는 스코프이다.</li>
      <li>application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.</li>
    </ul>
  </li>
</ol>

<h3 id="프로토타입-스코프">프로토타입 스코프</h3>
<ul>
  <li>컨테이너에 조회하면 항상 새로운 인스턴스를 생성해서 반환한다.</li>
  <li>컨테이너는 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.</li>
</ul>

<h3 id="프로토타입-스코프---싱글톤-빈과-함께-사용시-문제">프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제</h3>
<ul>
  <li>싱글톤 빈이 의존관계 주입을 통해서 프로토타입 빈을 주입받아서 사용하는 경우</li>
  <li>주입 시점에 컨테이너에 프로토타입 빈을 요청한다.</li>
  <li>내부에 가지고 있는 프로토타입 빈은 이미 과거에 주입이 끝난 빈으로써 사용 할 때마다 새로 생성되는 것이 아니다.</li>
  <li>프로토타입 빈을 주입 시점에만 새로 생성하는게 아니라, 사용할 때 마다 새로 생성해서 사용하는 것을 원할 것이다.</li>
</ul>

<h3 id="프로토타입-스코프---싱글톤-빈과-함께-사용시-provider로-문제-해결">프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결</h3>
<ul>
  <li>가장 간단한 방법은 싱글톤 빈이 프로토타입을 사용할 때 마다 컨테이너에 새로 요청하는 것이다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">ApplicationContext</span> <span class="n">ac</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">logic</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">PrototypeBean</span> <span class="n">prototypeBean</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">PrototypeBean</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">prototypeBean</span><span class="o">.</span><span class="na">addCount</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">prototypeBean</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>의존관계를 외부에서 주입 받는게 아니라<code class="language-plaintext highlighter-rouge">ac.getBean(PrototypeBean.class)</code>처럼 직접 필요한 의존관계를 찾는 것을 Dependency Lookup 의존관계 조회라고 한다.</li>
  <li>단, 컨테이너 자체를 주입받게 되면 컨테이너에 종속적인 코드가 되고 단위 테스트의 어려움이 따른다.</li>
</ul>

<h4 id="objectfactory-objectprovider">ObjectFactory, ObjectProvider</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">ObjectProvider</span><span class="o">&lt;</span><span class="nc">PrototypeBean</span><span class="o">&gt;</span> <span class="n">prototypeBeanProvider</span><span class="o">;</span> 

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">logic</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">PrototypeBean</span> <span class="n">prototypeBean</span> <span class="o">=</span> <span class="n">prototypeBeanProvider</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
    <span class="n">prototypeBean</span><span class="o">.</span><span class="na">addCount</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">prototypeBean</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>과거에는 <code class="language-plaintext highlighter-rouge">ObjectFactory</code> 가 있었는데, 여기에 편의 기능을 추가해서 <code class="language-plaintext highlighter-rouge">ObjectProvider</code> 가 만들어졌다.</li>
  <li><code class="language-plaintext highlighter-rouge">ObjectProvider</code> 는 지금 딱 필요한 DL 정도의 기능만 제공한다.</li>
</ul>

<h4 id="jsr-330-provider">JSR-330 Provider</h4>
<p>이 방법을 사용하려면 <code class="language-plaintext highlighter-rouge">javax.inject:javax.inject:1</code> 라이브러리를 gradle에 추가해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">Provider</span><span class="o">&lt;</span><span class="nc">PrototypeBean</span><span class="o">&gt;</span> <span class="n">provider</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">logic</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">PrototypeBean</span> <span class="n">prototypeBean</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="n">prototypeBean</span><span class="o">.</span><span class="na">addCount</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">prototypeBean</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.</li>
</ul>

<h3 id="웹-스코프">웹 스코프</h3>
<ul>
  <li>웹 스코프는 웹 환경에서만 동작한다.</li>
  <li>스프링이 해당 스코프의 빈 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.</li>
  <li>웹 스코프 종류
    <ol>
      <li>request: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프로써 각각의 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.</li>
      <li>session: HTTP Session과 동일한 생명주기를 가지는 스코프</li>
    </ol>
  </li>
</ul>

<h3 id="request-스코프와-provider">request 스코프와 Provider</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LogDemoController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">LogDemoService</span> <span class="n">logDemoService</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">ObjectProvider</span><span class="o">&lt;</span><span class="nc">MyLogger</span><span class="o">&gt;</span> <span class="n">myLoggerProvider</span><span class="o">;</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"log-demo"</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">logDemo</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">requestURL</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getRequestURL</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
        <span class="nc">MyLogger</span> <span class="n">myLogger</span> <span class="o">=</span> <span class="n">myLoggerProvider</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
        <span class="n">myLogger</span><span class="o">.</span><span class="na">setRequestURL</span><span class="o">(</span><span class="n">requestURL</span><span class="o">);</span>
        <span class="n">myLogger</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"controller test"</span><span class="o">);</span>
        <span class="n">logDemoService</span><span class="o">.</span><span class="na">logic</span><span class="o">(</span><span class="s">"testId"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"OK"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ObjectProvider</code> 덕분에 <code class="language-plaintext highlighter-rouge">ObjectProvider.getObject()</code> 를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.</li>
</ul>

<h3 id="스코프와-프록시">스코프와 프록시</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Scope</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"request"</span><span class="o">,</span> <span class="n">proxyMode</span> <span class="o">=</span> <span class="nc">ScopedProxyMode</span><span class="o">.</span><span class="na">TARGET_CLASS</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyLogger</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>적용 대상이 인터페이스가 아닌 클래스면 <code class="language-plaintext highlighter-rouge">TARGET_CLASS</code> 를 선택</li>
  <li>적용 대상이 인터페이스면 <code class="language-plaintext highlighter-rouge">INTERFACES</code> 를 선택</li>
  <li>이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">@Scope</code> 의 <code class="language-plaintext highlighter-rouge">proxyMode = ScopedProxyMode.TARGET_CLASS)</code> 를 설정하면 스프링 컨테이너는 CGLIB 라는 바이트코드를 조작하는 라이브러리를 사용해서, MyLogger를 상속받은 가짜 프록시 객체를 생성한다.</li>
  <li>그리고 스프링 컨테이너에 “myLogger”라는 이름으로 진짜 대신에 이 가짜 프록시 객체를 등록한다.</li>
  <li><code class="language-plaintext highlighter-rouge">ac.getBean("myLogger", MyLogger.class)</code>로 조회해도 프록시 객체가 조회되는 것을 확인할 수 있다. 그래서 의존관계 주입도 이 가짜 프록시 객체가 주입된다.</li>
  <li>이 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 위임 로직이 들어있다. 내부에 단순한 위임 로직만 있고, 싱글톤 처럼 동작한다.</li>
</ul>


        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 태그: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#object-oriented" class="page__taxonomy-item" rel="tag">Object-oriented</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#spring" class="page__taxonomy-item" rel="tag">Spring</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 카테고리: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#spring-core" class="page__taxonomy-item" rel="tag">Spring/Core</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time datetime="2021-09-22T00:00:00+09:00">September 22, 2021</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">공유하기</h4>
  

  <a href="https://twitter.com/intent/tweet?text=%5BSpring%5D%5BCore%5D+%EC%8A%A4%ED%94%84%EB%A7%81+%ED%95%B5%EC%8B%AC+%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8%20https%3A%2F%2Frere950303.github.io%2Fspring%2Fcore%2FSpringCore_basic%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="공유하기 Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Frere950303.github.io%2Fspring%2Fcore%2FSpringCore_basic%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="공유하기 Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Frere950303.github.io%2Fspring%2Fcore%2FSpringCore_basic%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="공유하기 LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/sql/where&having/" class="pagination--pager" title="[SQL] WHERE과 HAVING의 차이
">이전</a>
    
    
      <a href="/spring/mvc/SpringMVC-part1/" class="pagination--pager" title="[Spring][MVC] SpringMVC-part1
">다음</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">연관글</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/java/singleton/" rel="permalink">[Java] 생성자나 열거 타입으로 싱글턴임을 보증하라
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2022-05-21T00:00:00+09:00">May 21, 2022</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          1 분 소요
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/java/builder/" rel="permalink">[Java] 생성자의 매개변수가 많을 때는 빌더를 고려해라
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2022-05-20T00:00:00+09:00">May 20, 2022</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          1 분 소요
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/spring/security/aop/" rel="permalink">[Spring][Security] AOP를 통한 메소드 시큐리티 구현
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2022-04-17T00:00:00+09:00">April 17, 2022</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          2 분 소요
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/spring/security/interceptor/" rel="permalink">[Spring][Security] 인터셉터, Oauth2, JWT를 통한 인증 구현
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2022-04-13T00:00:00+09:00">April 13, 2022</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          2 분 소요
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      
        
      
        
      
        
          <li><a href="https://github.com/rere950303" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    
    
    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 yhw. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'rere950303/rere950303.github.io');
    script.setAttribute('issue-term', 'title');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
