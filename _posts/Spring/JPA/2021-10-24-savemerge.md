---
title: "[Spring][JPA] 변경 감지와 병합"
last\_modified\_at: 2021-10-24T 1:03 +09:00
header:
  overlay\_color: "#333"
categories:
  - Spring/JPA
tags:
  - JPA
  - Spring
  - save
  - merge
---
## 준영속 엔티티
식별자(ID)를 가지고 있는 엔티티로써 영속성 컨텍스트가 더는 관리하지 않는것을 말한다. 따라서 해당 엔티티의 속성을 변경해도 변경감지를 통한 update쿼리가 생성되지 않는다.

## 준영속 엔티티를 수정하는 2가지 방법
1. 변경 감지 기능 사용
   - 영속성 컨텍스트에서 영속상태인 엔티티를 조회한 후에 트랜잭션 안에서 속성을 변경하고 변경 감지 기능을 통해 트랜잭션 시점의 플러쉬로 데이터베이스 UPDATE SQL 실행
2. 병합 사용(`merge()`)
   - 이는 준영속 상태의 엔티티를 영속 상태로 변경할 떄 사용하는 기능이다.
   - 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다.
   - 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차 캐시에 저장한다.
   - 조회한 영속 엔티티( mergeMember )에 member 엔티티의 값을 채워 넣는다.
   - 영속 상태인 mergeMember를 반환한다.
   - 트랜잭션 커밋 시점에 변경 감지 기능이 동작해서 데이터베이스에 UPDATE SQL 실행
  
- 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다. 병합시 값이 없으면 `null` 로 업데이트 할 위험도 있다. (병합은 모든 필드를 교체한다.)
- `save()` 메서드는 식별자 값이 없으면( `null` ) 새로운 엔티티로 판단해서 영속화(persist)하고 식별자가 있으면 병합(`merge`)
  - `save()` 메서드는 식별자를 자동 생성해야 정상 동작한다. `@GeneratedValue` 사용시 식별자 없이 `save()` 메서드를 호출하면 `persist()` 가 호출되면서 식별자 값이 자동으로 할당된다. 반면에 식별자를 직접 할당하도록 `@Id` 만 선언 했다고 가정하자. 이 경우 식별자를 직접 할당하지 않고, `save()` 메서드를 호출하면 식별자가 없는 상태로 `persist()` 를 호출한다. 그러면 식별자가 없다는 예외가 발생한다.

## 가장 좋은 해결 방법
가급적 변경 감지 기능을 사용하는 것이 좋다. 이를 위해서는 트랜잭션 단위인 서비스 계층에 준영속 엔티티의 식별자와 변경할 속성값을 파라미터나 DTO형태로 명확하게 전달해주는 것이 매우 중요하다. 병합의 경우 의도치 않는 변경이나 `null` 값 주입의 우려가 있기 때문이다.